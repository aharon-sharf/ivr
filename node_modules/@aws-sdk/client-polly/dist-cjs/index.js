'use strict';

var middlewareHostHeader = require('@aws-sdk/middleware-host-header');
var middlewareLogger = require('@aws-sdk/middleware-logger');
var middlewareRecursionDetection = require('@aws-sdk/middleware-recursion-detection');
var middlewareUserAgent = require('@aws-sdk/middleware-user-agent');
var configResolver = require('@smithy/config-resolver');
var core = require('@smithy/core');
var schema = require('@smithy/core/schema');
var middlewareContentLength = require('@smithy/middleware-content-length');
var middlewareEndpoint = require('@smithy/middleware-endpoint');
var middlewareRetry = require('@smithy/middleware-retry');
var smithyClient = require('@smithy/smithy-client');
var httpAuthSchemeProvider = require('./auth/httpAuthSchemeProvider');
var runtimeConfig = require('./runtimeConfig');
var regionConfigResolver = require('@aws-sdk/region-config-resolver');
var protocolHttp = require('@smithy/protocol-http');

const resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "polly",
    });
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig), smithyClient.getDefaultExtensionConfiguration(runtimeConfig), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
};

class PollyClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
        const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
        const _config_4 = configResolver.resolveRegionConfig(_config_3);
        const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
        const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
        const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
        this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
        this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
        this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
        this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
        this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
        this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultPollyHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            }),
        }));
        this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

let PollyServiceException$1 = class PollyServiceException extends smithyClient.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, PollyServiceException.prototype);
    }
};

let LexiconNotFoundException$1 = class LexiconNotFoundException extends PollyServiceException$1 {
    name = "LexiconNotFoundException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "LexiconNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, LexiconNotFoundException.prototype);
    }
};
let ServiceFailureException$1 = class ServiceFailureException extends PollyServiceException$1 {
    name = "ServiceFailureException";
    $fault = "server";
    constructor(opts) {
        super({
            name: "ServiceFailureException",
            $fault: "server",
            ...opts,
        });
        Object.setPrototypeOf(this, ServiceFailureException.prototype);
    }
};
let InvalidNextTokenException$1 = class InvalidNextTokenException extends PollyServiceException$1 {
    name = "InvalidNextTokenException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidNextTokenException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidNextTokenException.prototype);
    }
};
let EngineNotSupportedException$1 = class EngineNotSupportedException extends PollyServiceException$1 {
    name = "EngineNotSupportedException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "EngineNotSupportedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, EngineNotSupportedException.prototype);
    }
};
let InvalidTaskIdException$1 = class InvalidTaskIdException extends PollyServiceException$1 {
    name = "InvalidTaskIdException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidTaskIdException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidTaskIdException.prototype);
    }
};
let SynthesisTaskNotFoundException$1 = class SynthesisTaskNotFoundException extends PollyServiceException$1 {
    name = "SynthesisTaskNotFoundException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "SynthesisTaskNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, SynthesisTaskNotFoundException.prototype);
    }
};
let InvalidLexiconException$1 = class InvalidLexiconException extends PollyServiceException$1 {
    name = "InvalidLexiconException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidLexiconException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidLexiconException.prototype);
    }
};
let InvalidS3BucketException$1 = class InvalidS3BucketException extends PollyServiceException$1 {
    name = "InvalidS3BucketException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidS3BucketException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidS3BucketException.prototype);
    }
};
let InvalidS3KeyException$1 = class InvalidS3KeyException extends PollyServiceException$1 {
    name = "InvalidS3KeyException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidS3KeyException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidS3KeyException.prototype);
    }
};
let InvalidSampleRateException$1 = class InvalidSampleRateException extends PollyServiceException$1 {
    name = "InvalidSampleRateException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidSampleRateException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSampleRateException.prototype);
    }
};
let InvalidSnsTopicArnException$1 = class InvalidSnsTopicArnException extends PollyServiceException$1 {
    name = "InvalidSnsTopicArnException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidSnsTopicArnException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSnsTopicArnException.prototype);
    }
};
let InvalidSsmlException$1 = class InvalidSsmlException extends PollyServiceException$1 {
    name = "InvalidSsmlException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidSsmlException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSsmlException.prototype);
    }
};
let LanguageNotSupportedException$1 = class LanguageNotSupportedException extends PollyServiceException$1 {
    name = "LanguageNotSupportedException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "LanguageNotSupportedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, LanguageNotSupportedException.prototype);
    }
};
let LexiconSizeExceededException$1 = class LexiconSizeExceededException extends PollyServiceException$1 {
    name = "LexiconSizeExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "LexiconSizeExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, LexiconSizeExceededException.prototype);
    }
};
let MarksNotSupportedForFormatException$1 = class MarksNotSupportedForFormatException extends PollyServiceException$1 {
    name = "MarksNotSupportedForFormatException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "MarksNotSupportedForFormatException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MarksNotSupportedForFormatException.prototype);
    }
};
let MaxLexemeLengthExceededException$1 = class MaxLexemeLengthExceededException extends PollyServiceException$1 {
    name = "MaxLexemeLengthExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "MaxLexemeLengthExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MaxLexemeLengthExceededException.prototype);
    }
};
let MaxLexiconsNumberExceededException$1 = class MaxLexiconsNumberExceededException extends PollyServiceException$1 {
    name = "MaxLexiconsNumberExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "MaxLexiconsNumberExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MaxLexiconsNumberExceededException.prototype);
    }
};
let UnsupportedPlsAlphabetException$1 = class UnsupportedPlsAlphabetException extends PollyServiceException$1 {
    name = "UnsupportedPlsAlphabetException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "UnsupportedPlsAlphabetException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedPlsAlphabetException.prototype);
    }
};
let UnsupportedPlsLanguageException$1 = class UnsupportedPlsLanguageException extends PollyServiceException$1 {
    name = "UnsupportedPlsLanguageException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "UnsupportedPlsLanguageException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedPlsLanguageException.prototype);
    }
};
let SsmlMarksNotSupportedForTextTypeException$1 = class SsmlMarksNotSupportedForTextTypeException extends PollyServiceException$1 {
    name = "SsmlMarksNotSupportedForTextTypeException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "SsmlMarksNotSupportedForTextTypeException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, SsmlMarksNotSupportedForTextTypeException.prototype);
    }
};
let TextLengthExceededException$1 = class TextLengthExceededException extends PollyServiceException$1 {
    name = "TextLengthExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "TextLengthExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TextLengthExceededException.prototype);
    }
};

const _A = "Alphabet";
const _ALC = "AdditionalLanguageCodes";
const _AS = "AudioStream";
const _At = "Attributes";
const _C = "Content";
const _CT = "CreationTime";
const _CT_ = "Content-Type";
const _CTo = "ContentType";
const _DL = "DeleteLexicon";
const _DLI = "DeleteLexiconInput";
const _DLO = "DeleteLexiconOutput";
const _DV = "DescribeVoices";
const _DVI = "DescribeVoicesInput";
const _DVO = "DescribeVoicesOutput";
const _E = "Engine";
const _ENSE = "EngineNotSupportedException";
const _G = "Gender";
const _GL = "GetLexicon";
const _GLI = "GetLexiconInput";
const _GLO = "GetLexiconOutput";
const _GSST = "GetSpeechSynthesisTask";
const _GSSTI = "GetSpeechSynthesisTaskInput";
const _GSSTO = "GetSpeechSynthesisTaskOutput";
const _I = "Id";
const _IALC = "IncludeAdditionalLanguageCodes";
const _ILE = "InvalidLexiconException";
const _INTE = "InvalidNextTokenException";
const _ISBE = "InvalidS3BucketException";
const _ISE = "InvalidSsmlException";
const _ISKE = "InvalidS3KeyException";
const _ISRE = "InvalidSampleRateException";
const _ISTAE = "InvalidSnsTopicArnException";
const _ITIE = "InvalidTaskIdException";
const _L = "Lexicon";
const _LA = "LexiconAttributes";
const _LAe = "LexiconArn";
const _LC = "LexiconContent";
const _LCa = "LanguageCode";
const _LCe = "LexemesCount";
const _LD = "LexiconDescription";
const _LDL = "LexiconDescriptionList";
const _LL = "ListLexicons";
const _LLI = "ListLexiconsInput";
const _LLO = "ListLexiconsOutput";
const _LM = "LastModified";
const _LN = "LexiconNames";
const _LNFE = "LexiconNotFoundException";
const _LNSE = "LanguageNotSupportedException";
const _LNa = "LanguageName";
const _LSEE = "LexiconSizeExceededException";
const _LSST = "ListSpeechSynthesisTasks";
const _LSSTI = "ListSpeechSynthesisTasksInput";
const _LSSTO = "ListSpeechSynthesisTasksOutput";
const _Le = "Lexicons";
const _MLLEE = "MaxLexemeLengthExceededException";
const _MLNEE = "MaxLexiconsNumberExceededException";
const _MNSFFE = "MarksNotSupportedForFormatException";
const _MR = "MaxResults";
const _N = "Name";
const _NT = "NextToken";
const _OF = "OutputFormat";
const _OSBN = "OutputS3BucketName";
const _OSKP = "OutputS3KeyPrefix";
const _OU = "OutputUri";
const _PL = "PutLexicon";
const _PLI = "PutLexiconInput";
const _PLO = "PutLexiconOutput";
const _RC = "RequestCharacters";
const _S = "Size";
const _SE = "SupportedEngines";
const _SFE = "ServiceFailureException";
const _SMNSFTTE = "SsmlMarksNotSupportedForTextTypeException";
const _SMT = "SpeechMarkTypes";
const _SR = "SampleRate";
const _SS = "SynthesizeSpeech";
const _SSI = "SynthesizeSpeechInput";
const _SSO = "SynthesizeSpeechOutput";
const _SSST = "StartSpeechSynthesisTask";
const _SSSTI = "StartSpeechSynthesisTaskInput";
const _SSSTO = "StartSpeechSynthesisTaskOutput";
const _ST = "SynthesisTask";
const _STA = "SnsTopicArn";
const _STNFE = "SynthesisTaskNotFoundException";
const _STy = "SynthesisTasks";
const _St = "Status";
const _T = "Text";
const _TI = "TaskId";
const _TLEE = "TextLengthExceededException";
const _TS = "TaskStatus";
const _TSR = "TaskStatusReason";
const _TT = "TextType";
const _UPAE = "UnsupportedPlsAlphabetException";
const _UPLE = "UnsupportedPlsLanguageException";
const _V = "Voices";
const _VI = "VoiceId";
const _VL = "VoiceList";
const _Vo = "Voice";
const _c = "client";
const _e = "error";
const _h = "http";
const _hE = "httpError";
const _hH = "httpHeader";
const _hQ = "httpQuery";
const _m = "message";
const _s = "streaming";
const _se = "server";
const _sm = "smithy.ts.sdk.synthetic.com.amazonaws.polly";
const _xaR = "x-amzn-RequestCharacters";
const n0 = "com.amazonaws.polly";
var AudioStream = [
    0,
    n0,
    _AS,
    {
        [_s]: 1,
    },
    42,
];
var LexiconContent = [0, n0, _LC, 8, 0];
var DeleteLexiconInput = [3, n0, _DLI, 0, [_N], [[0, 1]]];
var DeleteLexiconOutput = [3, n0, _DLO, 0, [], []];
var DescribeVoicesInput = [
    3,
    n0,
    _DVI,
    0,
    [_E, _LCa, _IALC, _NT],
    [
        [
            0,
            {
                [_hQ]: _E,
            },
        ],
        [
            0,
            {
                [_hQ]: _LCa,
            },
        ],
        [
            2,
            {
                [_hQ]: _IALC,
            },
        ],
        [
            0,
            {
                [_hQ]: _NT,
            },
        ],
    ],
];
var DescribeVoicesOutput = [3, n0, _DVO, 0, [_V, _NT], [() => VoiceList, 0]];
var EngineNotSupportedException = [
    -3,
    n0,
    _ENSE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(EngineNotSupportedException, EngineNotSupportedException$1);
var GetLexiconInput = [3, n0, _GLI, 0, [_N], [[0, 1]]];
var GetLexiconOutput = [
    3,
    n0,
    _GLO,
    0,
    [_L, _LA],
    [[() => Lexicon, 0], () => LexiconAttributes],
];
var GetSpeechSynthesisTaskInput = [3, n0, _GSSTI, 0, [_TI], [[0, 1]]];
var GetSpeechSynthesisTaskOutput = [3, n0, _GSSTO, 0, [_ST], [() => SynthesisTask]];
var InvalidLexiconException = [
    -3,
    n0,
    _ILE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidLexiconException, InvalidLexiconException$1);
var InvalidNextTokenException = [
    -3,
    n0,
    _INTE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidNextTokenException, InvalidNextTokenException$1);
var InvalidS3BucketException = [
    -3,
    n0,
    _ISBE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidS3BucketException, InvalidS3BucketException$1);
var InvalidS3KeyException = [
    -3,
    n0,
    _ISKE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidS3KeyException, InvalidS3KeyException$1);
var InvalidSampleRateException = [
    -3,
    n0,
    _ISRE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidSampleRateException, InvalidSampleRateException$1);
var InvalidSnsTopicArnException = [
    -3,
    n0,
    _ISTAE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidSnsTopicArnException, InvalidSnsTopicArnException$1);
var InvalidSsmlException = [
    -3,
    n0,
    _ISE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidSsmlException, InvalidSsmlException$1);
var InvalidTaskIdException = [
    -3,
    n0,
    _ITIE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(InvalidTaskIdException, InvalidTaskIdException$1);
var LanguageNotSupportedException = [
    -3,
    n0,
    _LNSE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(LanguageNotSupportedException, LanguageNotSupportedException$1);
var Lexicon = [3, n0, _L, 0, [_C, _N], [[() => LexiconContent, 0], 0]];
var LexiconAttributes = [
    3,
    n0,
    _LA,
    0,
    [_A, _LCa, _LM, _LAe, _LCe, _S],
    [0, 0, 4, 0, 1, 1],
];
var LexiconDescription = [3, n0, _LD, 0, [_N, _At], [0, () => LexiconAttributes]];
var LexiconNotFoundException = [
    -3,
    n0,
    _LNFE,
    {
        [_e]: _c,
        [_hE]: 404,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(LexiconNotFoundException, LexiconNotFoundException$1);
var LexiconSizeExceededException = [
    -3,
    n0,
    _LSEE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(LexiconSizeExceededException, LexiconSizeExceededException$1);
var ListLexiconsInput = [
    3,
    n0,
    _LLI,
    0,
    [_NT],
    [
        [
            0,
            {
                [_hQ]: _NT,
            },
        ],
    ],
];
var ListLexiconsOutput = [3, n0, _LLO, 0, [_Le, _NT], [() => LexiconDescriptionList, 0]];
var ListSpeechSynthesisTasksInput = [
    3,
    n0,
    _LSSTI,
    0,
    [_MR, _NT, _St],
    [
        [
            1,
            {
                [_hQ]: _MR,
            },
        ],
        [
            0,
            {
                [_hQ]: _NT,
            },
        ],
        [
            0,
            {
                [_hQ]: _St,
            },
        ],
    ],
];
var ListSpeechSynthesisTasksOutput = [
    3,
    n0,
    _LSSTO,
    0,
    [_NT, _STy],
    [0, () => SynthesisTasks],
];
var MarksNotSupportedForFormatException = [
    -3,
    n0,
    _MNSFFE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(MarksNotSupportedForFormatException, MarksNotSupportedForFormatException$1);
var MaxLexemeLengthExceededException = [
    -3,
    n0,
    _MLLEE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(MaxLexemeLengthExceededException, MaxLexemeLengthExceededException$1);
var MaxLexiconsNumberExceededException = [
    -3,
    n0,
    _MLNEE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(MaxLexiconsNumberExceededException, MaxLexiconsNumberExceededException$1);
var PutLexiconInput = [
    3,
    n0,
    _PLI,
    0,
    [_N, _C],
    [
        [0, 1],
        [() => LexiconContent, 0],
    ],
];
var PutLexiconOutput = [3, n0, _PLO, 0, [], []];
var ServiceFailureException = [
    -3,
    n0,
    _SFE,
    {
        [_e]: _se,
        [_hE]: 500,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(ServiceFailureException, ServiceFailureException$1);
var SsmlMarksNotSupportedForTextTypeException = [
    -3,
    n0,
    _SMNSFTTE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(SsmlMarksNotSupportedForTextTypeException, SsmlMarksNotSupportedForTextTypeException$1);
var StartSpeechSynthesisTaskInput = [
    3,
    n0,
    _SSSTI,
    0,
    [_E, _LCa, _LN, _OF, _OSBN, _OSKP, _SR, _STA, _SMT, _T, _TT, _VI],
    [0, 0, 64 | 0, 0, 0, 0, 0, 0, 64 | 0, 0, 0, 0],
];
var StartSpeechSynthesisTaskOutput = [3, n0, _SSSTO, 0, [_ST], [() => SynthesisTask]];
var SynthesisTask = [
    3,
    n0,
    _ST,
    0,
    [_E, _TI, _TS, _TSR, _OU, _CT, _RC, _STA, _LN, _OF, _SR, _SMT, _TT, _VI, _LCa],
    [0, 0, 0, 0, 0, 4, 1, 0, 64 | 0, 0, 0, 64 | 0, 0, 0, 0],
];
var SynthesisTaskNotFoundException = [
    -3,
    n0,
    _STNFE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(SynthesisTaskNotFoundException, SynthesisTaskNotFoundException$1);
var SynthesizeSpeechInput = [
    3,
    n0,
    _SSI,
    0,
    [_E, _LCa, _LN, _OF, _SR, _SMT, _T, _TT, _VI],
    [0, 0, 64 | 0, 0, 0, 64 | 0, 0, 0, 0],
];
var SynthesizeSpeechOutput = [
    3,
    n0,
    _SSO,
    0,
    [_AS, _CTo, _RC],
    [
        [() => AudioStream, 16],
        [
            0,
            {
                [_hH]: _CT_,
            },
        ],
        [
            1,
            {
                [_hH]: _xaR,
            },
        ],
    ],
];
var TextLengthExceededException = [
    -3,
    n0,
    _TLEE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(TextLengthExceededException, TextLengthExceededException$1);
var UnsupportedPlsAlphabetException = [
    -3,
    n0,
    _UPAE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(UnsupportedPlsAlphabetException, UnsupportedPlsAlphabetException$1);
var UnsupportedPlsLanguageException = [
    -3,
    n0,
    _UPLE,
    {
        [_e]: _c,
        [_hE]: 400,
    },
    [_m],
    [0],
];
schema.TypeRegistry.for(n0).registerError(UnsupportedPlsLanguageException, UnsupportedPlsLanguageException$1);
var Voice = [
    3,
    n0,
    _Vo,
    0,
    [_G, _I, _LCa, _LNa, _N, _ALC, _SE],
    [0, 0, 0, 0, 0, 64 | 0, 64 | 0],
];
var PollyServiceException = [-3, _sm, "PollyServiceException", 0, [], []];
schema.TypeRegistry.for(_sm).registerError(PollyServiceException, PollyServiceException$1);
var LexiconDescriptionList = [1, n0, _LDL, 0, () => LexiconDescription];
var SynthesisTasks = [1, n0, _STy, 0, () => SynthesisTask];
var VoiceList = [1, n0, _VL, 0, () => Voice];
var DeleteLexicon = [
    9,
    n0,
    _DL,
    {
        [_h]: ["DELETE", "/v1/lexicons/{Name}", 200],
    },
    () => DeleteLexiconInput,
    () => DeleteLexiconOutput,
];
var DescribeVoices = [
    9,
    n0,
    _DV,
    {
        [_h]: ["GET", "/v1/voices", 200],
    },
    () => DescribeVoicesInput,
    () => DescribeVoicesOutput,
];
var GetLexicon = [
    9,
    n0,
    _GL,
    {
        [_h]: ["GET", "/v1/lexicons/{Name}", 200],
    },
    () => GetLexiconInput,
    () => GetLexiconOutput,
];
var GetSpeechSynthesisTask = [
    9,
    n0,
    _GSST,
    {
        [_h]: ["GET", "/v1/synthesisTasks/{TaskId}", 200],
    },
    () => GetSpeechSynthesisTaskInput,
    () => GetSpeechSynthesisTaskOutput,
];
var ListLexicons = [
    9,
    n0,
    _LL,
    {
        [_h]: ["GET", "/v1/lexicons", 200],
    },
    () => ListLexiconsInput,
    () => ListLexiconsOutput,
];
var ListSpeechSynthesisTasks = [
    9,
    n0,
    _LSST,
    {
        [_h]: ["GET", "/v1/synthesisTasks", 200],
    },
    () => ListSpeechSynthesisTasksInput,
    () => ListSpeechSynthesisTasksOutput,
];
var PutLexicon = [
    9,
    n0,
    _PL,
    {
        [_h]: ["PUT", "/v1/lexicons/{Name}", 200],
    },
    () => PutLexiconInput,
    () => PutLexiconOutput,
];
var StartSpeechSynthesisTask = [
    9,
    n0,
    _SSST,
    {
        [_h]: ["POST", "/v1/synthesisTasks", 200],
    },
    () => StartSpeechSynthesisTaskInput,
    () => StartSpeechSynthesisTaskOutput,
];
var SynthesizeSpeech = [
    9,
    n0,
    _SS,
    {
        [_h]: ["POST", "/v1/speech", 200],
    },
    () => SynthesizeSpeechInput,
    () => SynthesizeSpeechOutput,
];

class DeleteLexiconCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "DeleteLexicon", {})
    .n("PollyClient", "DeleteLexiconCommand")
    .sc(DeleteLexicon)
    .build() {
}

class DescribeVoicesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "DescribeVoices", {})
    .n("PollyClient", "DescribeVoicesCommand")
    .sc(DescribeVoices)
    .build() {
}

class GetLexiconCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "GetLexicon", {})
    .n("PollyClient", "GetLexiconCommand")
    .sc(GetLexicon)
    .build() {
}

class GetSpeechSynthesisTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "GetSpeechSynthesisTask", {})
    .n("PollyClient", "GetSpeechSynthesisTaskCommand")
    .sc(GetSpeechSynthesisTask)
    .build() {
}

class ListLexiconsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "ListLexicons", {})
    .n("PollyClient", "ListLexiconsCommand")
    .sc(ListLexicons)
    .build() {
}

class ListSpeechSynthesisTasksCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "ListSpeechSynthesisTasks", {})
    .n("PollyClient", "ListSpeechSynthesisTasksCommand")
    .sc(ListSpeechSynthesisTasks)
    .build() {
}

class PutLexiconCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "PutLexicon", {})
    .n("PollyClient", "PutLexiconCommand")
    .sc(PutLexicon)
    .build() {
}

class StartSpeechSynthesisTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "StartSpeechSynthesisTask", {})
    .n("PollyClient", "StartSpeechSynthesisTaskCommand")
    .sc(StartSpeechSynthesisTask)
    .build() {
}

class SynthesizeSpeechCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("Parrot_v1", "SynthesizeSpeech", {})
    .n("PollyClient", "SynthesizeSpeechCommand")
    .sc(SynthesizeSpeech)
    .build() {
}

const commands = {
    DeleteLexiconCommand,
    DescribeVoicesCommand,
    GetLexiconCommand,
    GetSpeechSynthesisTaskCommand,
    ListLexiconsCommand,
    ListSpeechSynthesisTasksCommand,
    PutLexiconCommand,
    StartSpeechSynthesisTaskCommand,
    SynthesizeSpeechCommand,
};
class Polly extends PollyClient {
}
smithyClient.createAggregatedClient(commands, Polly);

const paginateListSpeechSynthesisTasks = core.createPaginator(PollyClient, ListSpeechSynthesisTasksCommand, "NextToken", "NextToken", "MaxResults");

const Engine = {
    GENERATIVE: "generative",
    LONG_FORM: "long-form",
    NEURAL: "neural",
    STANDARD: "standard",
};
const LanguageCode = {
    ar_AE: "ar-AE",
    arb: "arb",
    ca_ES: "ca-ES",
    cmn_CN: "cmn-CN",
    cs_CZ: "cs-CZ",
    cy_GB: "cy-GB",
    da_DK: "da-DK",
    de_AT: "de-AT",
    de_CH: "de-CH",
    de_DE: "de-DE",
    en_AU: "en-AU",
    en_GB: "en-GB",
    en_GB_WLS: "en-GB-WLS",
    en_IE: "en-IE",
    en_IN: "en-IN",
    en_NZ: "en-NZ",
    en_SG: "en-SG",
    en_US: "en-US",
    en_ZA: "en-ZA",
    es_ES: "es-ES",
    es_MX: "es-MX",
    es_US: "es-US",
    fi_FI: "fi-FI",
    fr_BE: "fr-BE",
    fr_CA: "fr-CA",
    fr_FR: "fr-FR",
    hi_IN: "hi-IN",
    is_IS: "is-IS",
    it_IT: "it-IT",
    ja_JP: "ja-JP",
    ko_KR: "ko-KR",
    nb_NO: "nb-NO",
    nl_BE: "nl-BE",
    nl_NL: "nl-NL",
    pl_PL: "pl-PL",
    pt_BR: "pt-BR",
    pt_PT: "pt-PT",
    ro_RO: "ro-RO",
    ru_RU: "ru-RU",
    sv_SE: "sv-SE",
    tr_TR: "tr-TR",
    yue_CN: "yue-CN",
};
const Gender = {
    Female: "Female",
    Male: "Male",
};
const VoiceId = {
    Aditi: "Aditi",
    Adriano: "Adriano",
    Amy: "Amy",
    Andres: "Andres",
    Aria: "Aria",
    Arlet: "Arlet",
    Arthur: "Arthur",
    Astrid: "Astrid",
    Ayanda: "Ayanda",
    Bianca: "Bianca",
    Brian: "Brian",
    Burcu: "Burcu",
    Camila: "Camila",
    Carla: "Carla",
    Carmen: "Carmen",
    Celine: "Celine",
    Chantal: "Chantal",
    Conchita: "Conchita",
    Cristiano: "Cristiano",
    Daniel: "Daniel",
    Danielle: "Danielle",
    Dora: "Dora",
    Elin: "Elin",
    Emma: "Emma",
    Enrique: "Enrique",
    Ewa: "Ewa",
    Filiz: "Filiz",
    Gabrielle: "Gabrielle",
    Geraint: "Geraint",
    Giorgio: "Giorgio",
    Gregory: "Gregory",
    Gwyneth: "Gwyneth",
    Hala: "Hala",
    Hannah: "Hannah",
    Hans: "Hans",
    Hiujin: "Hiujin",
    Ida: "Ida",
    Ines: "Ines",
    Isabelle: "Isabelle",
    Ivy: "Ivy",
    Jacek: "Jacek",
    Jan: "Jan",
    Jasmine: "Jasmine",
    Jihye: "Jihye",
    Jitka: "Jitka",
    Joanna: "Joanna",
    Joey: "Joey",
    Justin: "Justin",
    Kajal: "Kajal",
    Karl: "Karl",
    Kazuha: "Kazuha",
    Kendra: "Kendra",
    Kevin: "Kevin",
    Kimberly: "Kimberly",
    Laura: "Laura",
    Lea: "Lea",
    Liam: "Liam",
    Lisa: "Lisa",
    Liv: "Liv",
    Lotte: "Lotte",
    Lucia: "Lucia",
    Lupe: "Lupe",
    Mads: "Mads",
    Maja: "Maja",
    Marlene: "Marlene",
    Mathieu: "Mathieu",
    Matthew: "Matthew",
    Maxim: "Maxim",
    Mia: "Mia",
    Miguel: "Miguel",
    Mizuki: "Mizuki",
    Naja: "Naja",
    Niamh: "Niamh",
    Nicole: "Nicole",
    Ola: "Ola",
    Olivia: "Olivia",
    Pedro: "Pedro",
    Penelope: "Penelope",
    Raveena: "Raveena",
    Remi: "Remi",
    Ricardo: "Ricardo",
    Ruben: "Ruben",
    Russell: "Russell",
    Ruth: "Ruth",
    Sabrina: "Sabrina",
    Salli: "Salli",
    Seoyeon: "Seoyeon",
    Sergio: "Sergio",
    Sofie: "Sofie",
    Stephen: "Stephen",
    Suvi: "Suvi",
    Takumi: "Takumi",
    Tatyana: "Tatyana",
    Thiago: "Thiago",
    Tomoko: "Tomoko",
    Vicki: "Vicki",
    Vitoria: "Vitoria",
    Zayd: "Zayd",
    Zeina: "Zeina",
    Zhiyu: "Zhiyu",
};
const OutputFormat = {
    JSON: "json",
    MP3: "mp3",
    OGG_OPUS: "ogg_opus",
    OGG_VORBIS: "ogg_vorbis",
    PCM: "pcm",
};
const SpeechMarkType = {
    SENTENCE: "sentence",
    SSML: "ssml",
    VISEME: "viseme",
    WORD: "word",
};
const TaskStatus = {
    COMPLETED: "completed",
    FAILED: "failed",
    IN_PROGRESS: "inProgress",
    SCHEDULED: "scheduled",
};
const TextType = {
    SSML: "ssml",
    TEXT: "text",
};

Object.defineProperty(exports, "$Command", {
    enumerable: true,
    get: function () { return smithyClient.Command; }
});
Object.defineProperty(exports, "__Client", {
    enumerable: true,
    get: function () { return smithyClient.Client; }
});
exports.DeleteLexiconCommand = DeleteLexiconCommand;
exports.DescribeVoicesCommand = DescribeVoicesCommand;
exports.Engine = Engine;
exports.EngineNotSupportedException = EngineNotSupportedException$1;
exports.Gender = Gender;
exports.GetLexiconCommand = GetLexiconCommand;
exports.GetSpeechSynthesisTaskCommand = GetSpeechSynthesisTaskCommand;
exports.InvalidLexiconException = InvalidLexiconException$1;
exports.InvalidNextTokenException = InvalidNextTokenException$1;
exports.InvalidS3BucketException = InvalidS3BucketException$1;
exports.InvalidS3KeyException = InvalidS3KeyException$1;
exports.InvalidSampleRateException = InvalidSampleRateException$1;
exports.InvalidSnsTopicArnException = InvalidSnsTopicArnException$1;
exports.InvalidSsmlException = InvalidSsmlException$1;
exports.InvalidTaskIdException = InvalidTaskIdException$1;
exports.LanguageCode = LanguageCode;
exports.LanguageNotSupportedException = LanguageNotSupportedException$1;
exports.LexiconNotFoundException = LexiconNotFoundException$1;
exports.LexiconSizeExceededException = LexiconSizeExceededException$1;
exports.ListLexiconsCommand = ListLexiconsCommand;
exports.ListSpeechSynthesisTasksCommand = ListSpeechSynthesisTasksCommand;
exports.MarksNotSupportedForFormatException = MarksNotSupportedForFormatException$1;
exports.MaxLexemeLengthExceededException = MaxLexemeLengthExceededException$1;
exports.MaxLexiconsNumberExceededException = MaxLexiconsNumberExceededException$1;
exports.OutputFormat = OutputFormat;
exports.Polly = Polly;
exports.PollyClient = PollyClient;
exports.PollyServiceException = PollyServiceException$1;
exports.PutLexiconCommand = PutLexiconCommand;
exports.ServiceFailureException = ServiceFailureException$1;
exports.SpeechMarkType = SpeechMarkType;
exports.SsmlMarksNotSupportedForTextTypeException = SsmlMarksNotSupportedForTextTypeException$1;
exports.StartSpeechSynthesisTaskCommand = StartSpeechSynthesisTaskCommand;
exports.SynthesisTaskNotFoundException = SynthesisTaskNotFoundException$1;
exports.SynthesizeSpeechCommand = SynthesizeSpeechCommand;
exports.TaskStatus = TaskStatus;
exports.TextLengthExceededException = TextLengthExceededException$1;
exports.TextType = TextType;
exports.UnsupportedPlsAlphabetException = UnsupportedPlsAlphabetException$1;
exports.UnsupportedPlsLanguageException = UnsupportedPlsLanguageException$1;
exports.VoiceId = VoiceId;
exports.paginateListSpeechSynthesisTasks = paginateListSpeechSynthesisTasks;
